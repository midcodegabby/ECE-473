
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00000228  0000029c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000228  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         0000102c  00000000  00000000  0000029c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000d73  00000000  00000000  000012c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  0000203b  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000204c  2**2
                  CONTENTS, READONLY
  6 .debug_info   000009f4  00000000  00000000  0000208c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000096a  00000000  00000000  00002a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001a  00000000  00000000  000033ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000371  00000000  00000000  00003404  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
   8:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
   c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  10:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  14:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  18:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  1c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  20:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  24:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  28:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  2c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  30:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  34:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  38:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  3c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  40:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  44:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  48:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  4c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  50:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  54:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  58:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  5c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  60:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  64:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  68:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  6c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  70:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  74:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  78:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  7c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  80:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  84:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  88:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  8c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  90:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  94:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  98:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  9c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  a0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  a4:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  a8:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61
  b8:	0e 94 c7 00 	call	0x18e	; 0x18e <main>
  bc:	0c 94 12 01 	jmp	0x224	; 0x224 <_exit>

000000c0 <__bad_interrupt>:
  c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c4 <delay_cycles>:
  c4:	00 97       	sbiw	r24, 0x00	; 0
  c6:	09 f4       	brne	.+2      	; 0xca <loop>
  c8:	08 95       	ret

000000ca <loop>:
	...
  d2:	01 97       	sbiw	r24, 0x01	; 1
  d4:	d1 f7       	brne	.-12     	; 0xca <loop>
  d6:	08 95       	ret

000000d8 <shift_debounce>:
#include <stdint.h>

int
shift_debounce(uint8_t volatile *PIN, uint8_t pin)
{
  d8:	fc 01       	movw	r30, r24
	
	//initialize a shift register
	uint8_t shift_register = 0x55;
  da:	95 e5       	ldi	r25, 0x55	; 85
  dc:	02 c0       	rjmp	.+4      	; 0xe2 <shift_debounce+0xa>

	while(1) {

		shift_register = (shift_register << 1) | (((*PIN >> pin)) & 1);
		if (shift_register == 255) break;
		else if (shift_register == 0) break;
  de:	99 23       	and	r25, r25
  e0:	81 f0       	breq	.+32     	; 0x102 <shift_debounce+0x2a>
	//initialize a shift register
	uint8_t shift_register = 0x55;

	while(1) {

		shift_register = (shift_register << 1) | (((*PIN >> pin)) & 1);
  e2:	20 81       	ld	r18, Z
  e4:	30 e0       	ldi	r19, 0x00	; 0
  e6:	06 2e       	mov	r0, r22
  e8:	02 c0       	rjmp	.+4      	; 0xee <shift_debounce+0x16>
  ea:	35 95       	asr	r19
  ec:	27 95       	ror	r18
  ee:	0a 94       	dec	r0
  f0:	e2 f7       	brpl	.-8      	; 0xea <shift_debounce+0x12>
  f2:	21 70       	andi	r18, 0x01	; 1
  f4:	99 0f       	add	r25, r25
  f6:	92 2b       	or	r25, r18
		if (shift_register == 255) break;
  f8:	9f 3f       	cpi	r25, 0xFF	; 255
  fa:	89 f7       	brne	.-30     	; 0xde <shift_debounce+0x6>
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	90 e0       	ldi	r25, 0x00	; 0
		else if (shift_register == 0) break;
	}
	
	return ((shift_register >> 7) & 1);
}
 100:	08 95       	ret
 102:	80 e0       	ldi	r24, 0x00	; 0
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	08 95       	ret

00000108 <delay_debounce>:

#include "delay_cycles.h"

int
delay_debounce(uint8_t volatile *PIN, uint8_t pin, uint16_t cycles)
{
 108:	0f 93       	push	r16
 10a:	1f 93       	push	r17
 10c:	cf 93       	push	r28

	if ((*PIN) & (1 << pin)) return 1; //button not pressed
 10e:	fc 01       	movw	r30, r24
 110:	20 81       	ld	r18, Z
 112:	30 e0       	ldi	r19, 0x00	; 0
 114:	06 2e       	mov	r0, r22
 116:	02 c0       	rjmp	.+4      	; 0x11c <delay_debounce+0x14>
 118:	35 95       	asr	r19
 11a:	27 95       	ror	r18
 11c:	0a 94       	dec	r0
 11e:	e2 f7       	brpl	.-8      	; 0x118 <delay_debounce+0x10>
 120:	20 ff       	sbrs	r18, 0
 122:	06 c0       	rjmp	.+12     	; 0x130 <delay_debounce+0x28>
 124:	81 e0       	ldi	r24, 0x01	; 1
 126:	90 e0       	ldi	r25, 0x00	; 0
		delay_cycles(cycles);

		if (!((*PIN >> pin) & 1)) return 0; //button has been pressed and is still pressed
	  	else return 1; //button did not remain pressed
	}
}
 128:	cf 91       	pop	r28
 12a:	1f 91       	pop	r17
 12c:	0f 91       	pop	r16
 12e:	08 95       	ret
 130:	c6 2f       	mov	r28, r22
 132:	8c 01       	movw	r16, r24

	if ((*PIN) & (1 << pin)) return 1; //button not pressed

	else {
		//delay by cycles
		delay_cycles(cycles);
 134:	ca 01       	movw	r24, r20
 136:	0e 94 62 00 	call	0xc4	; 0xc4 <delay_cycles>

		if (!((*PIN >> pin) & 1)) return 0; //button has been pressed and is still pressed
 13a:	f8 01       	movw	r30, r16
 13c:	80 81       	ld	r24, Z
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	02 c0       	rjmp	.+4      	; 0x146 <delay_debounce+0x3e>
 142:	95 95       	asr	r25
 144:	87 95       	ror	r24
 146:	ca 95       	dec	r28
 148:	e2 f7       	brpl	.-8      	; 0x142 <delay_debounce+0x3a>

int
delay_debounce(uint8_t volatile *PIN, uint8_t pin, uint16_t cycles)
{

	if ((*PIN) & (1 << pin)) return 1; //button not pressed
 14a:	81 70       	andi	r24, 0x01	; 1
 14c:	99 27       	eor	r25, r25
		delay_cycles(cycles);

		if (!((*PIN >> pin) & 1)) return 0; //button has been pressed and is still pressed
	  	else return 1; //button did not remain pressed
	}
}
 14e:	cf 91       	pop	r28
 150:	1f 91       	pop	r17
 152:	0f 91       	pop	r16
 154:	08 95       	ret

00000156 <async_debounce>:
 156:	fa 01       	movw	r30, r20
 158:	dc 01       	movw	r26, r24
 15a:	8c 91       	ld	r24, X
 15c:	86 ff       	sbrs	r24, 6
 15e:	0c c0       	rjmp	.+24     	; 0x178 <async_debounce+0x22>
 160:	80 81       	ld	r24, Z
 162:	87 fd       	sbrc	r24, 7
 164:	0c c0       	rjmp	.+24     	; 0x17e <async_debounce+0x28>
 166:	8f 5f       	subi	r24, 0xFF	; 255
 168:	80 83       	st	Z, r24
 16a:	80 34       	cpi	r24, 0x40	; 64
 16c:	54 f4       	brge	.+20     	; 0x182 <async_debounce+0x2c>
 16e:	81 3c       	cpi	r24, 0xC1	; 193
 170:	14 f4       	brge	.+4      	; 0x176 <async_debounce+0x20>
 172:	80 ec       	ldi	r24, 0xC0	; 192
 174:	80 83       	st	Z, r24
 176:	08 95       	ret
 178:	80 81       	ld	r24, Z
 17a:	18 16       	cp	r1, r24
 17c:	2c f4       	brge	.+10     	; 0x188 <async_debounce+0x32>
 17e:	10 82       	st	Z, r1
 180:	08 95       	ret
 182:	80 e4       	ldi	r24, 0x40	; 64
 184:	80 83       	st	Z, r24
 186:	08 95       	ret
 188:	81 50       	subi	r24, 0x01	; 1
 18a:	80 83       	st	Z, r24
 18c:	ee cf       	rjmp	.-36     	; 0x16a <async_debounce+0x14>

0000018e <main>:
#include "shift_debounce.h"
#include "async_debounce.h"

int
main()
{
 18e:	cf 93       	push	r28
 190:	df 93       	push	r29
 192:	1f 92       	push	r1
 194:	cd b7       	in	r28, 0x3d	; 61
 196:	de b7       	in	r29, 0x3e	; 62
  /* Set up Port B for LED output */
  DDRB = 0xff;
 198:	8f ef       	ldi	r24, 0xFF	; 255
 19a:	84 b9       	out	0x04, r24	; 4
  //PORTB = 0x00; //set to off
  PORTB = 0b10100000; //set to off
 19c:	90 ea       	ldi	r25, 0xA0	; 160
 19e:	95 b9       	out	0x05, r25	; 5

  /* Set up Port D for Input */
  DDRD = 0x00;
 1a0:	1a b8       	out	0x0a, r1	; 10
  PORTD = 0xff; /* Pull-up pins */
 1a2:	8b b9       	out	0x0b, r24	; 11

  uint8_t pd5_state = 1;
  uint8_t prevpd5_state = 1;
  int8_t pd6_cnt = 0;
 1a4:	19 82       	std	Y+1, r1	; 0x01
  uint8_t pd6_state = 0;
  uint8_t pd7_state = 1;
 1a6:	ff 24       	eor	r15, r15
 1a8:	f3 94       	inc	r15
  PORTD = 0xff; /* Pull-up pins */

  uint8_t pd5_state = 1;
  uint8_t prevpd5_state = 1;
  int8_t pd6_cnt = 0;
  uint8_t pd6_state = 0;
 1aa:	e1 2c       	mov	r14, r1

  /* Set up Port D for Input */
  DDRD = 0x00;
  PORTD = 0xff; /* Pull-up pins */

  uint8_t pd5_state = 1;
 1ac:	01 e0       	ldi	r16, 0x01	; 1
	
	//get the current pd5 state; 0 = on, 1 = off	
	pd5_state = shift_debounce(&PIND, 5); //debounce PD5  
	 
	//use if statement to check for rising edge only then toggle PB5
	if ((pd5_state != prevpd5_state) && (prevpd5_state == 0)) PORTB ^= (1 << 5); 
 1ae:	80 e2       	ldi	r24, 0x20	; 32
 1b0:	d8 2e       	mov	r13, r24
	//use if statement to check for rising edge only then toggle PB7
	if ((pd7_state != prevpd7_state) && (prevpd7_state == 0)) PORTB ^= (1 << 7); 

    	if (pd6_cnt > 32 && pd6_state == 0) { //check if pd6_cnt is over 32
      		pd6_state = 1; // 1 is on
      		PORTB ^= (1 << 6);
 1b2:	90 e4       	ldi	r25, 0x40	; 64
 1b4:	c9 2e       	mov	r12, r25
 1b6:	09 c0       	rjmp	.+18     	; 0x1ca <main+0x3c>
	pd7_state = delay_debounce(&PIND, 7, cycles);

	//use if statement to check for rising edge only then toggle PB7
	if ((pd7_state != prevpd7_state) && (prevpd7_state == 0)) PORTB ^= (1 << 7); 

    	if (pd6_cnt > 32 && pd6_state == 0) { //check if pd6_cnt is over 32
 1b8:	e1 10       	cpse	r14, r1
 1ba:	31 c0       	rjmp	.+98     	; 0x21e <main+0x90>
      		pd6_state = 1; // 1 is on
      		PORTB ^= (1 << 6);
 1bc:	95 b1       	in	r25, 0x05	; 5
 1be:	9c 25       	eor	r25, r12
 1c0:	95 b9       	out	0x05, r25	; 5

	//use if statement to check for rising edge only then toggle PB7
	if ((pd7_state != prevpd7_state) && (prevpd7_state == 0)) PORTB ^= (1 << 7); 

    	if (pd6_cnt > 32 && pd6_state == 0) { //check if pd6_cnt is over 32
      		pd6_state = 1; // 1 is on
 1c2:	ee 24       	eor	r14, r14
 1c4:	e3 94       	inc	r14
	//update the previous states
	prevpd5_state = pd5_state;
	prevpd7_state = pd7_state;
	
	//get the current pd5 state; 0 = on, 1 = off	
	pd5_state = shift_debounce(&PIND, 5); //debounce PD5  
 1c6:	01 2f       	mov	r16, r17
	if ((pd5_state != prevpd5_state) && (prevpd5_state == 0)) PORTB ^= (1 << 5); 

    	async_debounce(&PIND, 6, &pd6_cnt); //debounce PD6
	
	//get the current pd7 state
	pd7_state = delay_debounce(&PIND, 7, cycles);
 1c8:	f8 2e       	mov	r15, r24
	//update the previous states
	prevpd5_state = pd5_state;
	prevpd7_state = pd7_state;
	
	//get the current pd5 state; 0 = on, 1 = off	
	pd5_state = shift_debounce(&PIND, 5); //debounce PD5  
 1ca:	65 e0       	ldi	r22, 0x05	; 5
 1cc:	89 e2       	ldi	r24, 0x29	; 41
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	0e 94 6c 00 	call	0xd8	; 0xd8 <shift_debounce>
 1d4:	18 2f       	mov	r17, r24
	 
	//use if statement to check for rising edge only then toggle PB5
	if ((pd5_state != prevpd5_state) && (prevpd5_state == 0)) PORTB ^= (1 << 5); 
 1d6:	08 17       	cp	r16, r24
 1d8:	29 f0       	breq	.+10     	; 0x1e4 <main+0x56>
 1da:	01 11       	cpse	r16, r1
 1dc:	03 c0       	rjmp	.+6      	; 0x1e4 <main+0x56>
 1de:	85 b1       	in	r24, 0x05	; 5
 1e0:	8d 25       	eor	r24, r13
 1e2:	85 b9       	out	0x05, r24	; 5

    	async_debounce(&PIND, 6, &pd6_cnt); //debounce PD6
 1e4:	ae 01       	movw	r20, r28
 1e6:	4f 5f       	subi	r20, 0xFF	; 255
 1e8:	5f 4f       	sbci	r21, 0xFF	; 255
 1ea:	66 e0       	ldi	r22, 0x06	; 6
 1ec:	89 e2       	ldi	r24, 0x29	; 41
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	0e 94 ab 00 	call	0x156	; 0x156 <async_debounce>
	
	//get the current pd7 state
	pd7_state = delay_debounce(&PIND, 7, cycles);
 1f4:	4a e0       	ldi	r20, 0x0A	; 10
 1f6:	50 e0       	ldi	r21, 0x00	; 0
 1f8:	67 e0       	ldi	r22, 0x07	; 7
 1fa:	89 e2       	ldi	r24, 0x29	; 41
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	0e 94 84 00 	call	0x108	; 0x108 <delay_debounce>

	//use if statement to check for rising edge only then toggle PB7
	if ((pd7_state != prevpd7_state) && (prevpd7_state == 0)) PORTB ^= (1 << 7); 
 202:	f8 16       	cp	r15, r24
 204:	29 f0       	breq	.+10     	; 0x210 <main+0x82>
 206:	f1 10       	cpse	r15, r1
 208:	03 c0       	rjmp	.+6      	; 0x210 <main+0x82>
 20a:	95 b1       	in	r25, 0x05	; 5
 20c:	90 58       	subi	r25, 0x80	; 128
 20e:	95 b9       	out	0x05, r25	; 5

    	if (pd6_cnt > 32 && pd6_state == 0) { //check if pd6_cnt is over 32
 210:	99 81       	ldd	r25, Y+1	; 0x01
 212:	91 32       	cpi	r25, 0x21	; 33
 214:	8c f6       	brge	.-94     	; 0x1b8 <main+0x2a>
      		pd6_state = 1; // 1 is on
      		PORTB ^= (1 << 6);
	}

      	//check other condition, where pd6_cnt is below 32 and the leds are on
     	else if (pd6_cnt < 32 && pd6_state == 1) {
 216:	90 32       	cpi	r25, 0x20	; 32
 218:	b1 f2       	breq	.-84     	; 0x1c6 <main+0x38>
      		pd6_state = 0; // 0 is off
 21a:	e1 2c       	mov	r14, r1
 21c:	d4 cf       	rjmp	.-88     	; 0x1c6 <main+0x38>
 21e:	ee 24       	eor	r14, r14
 220:	e3 94       	inc	r14
 222:	d1 cf       	rjmp	.-94     	; 0x1c6 <main+0x38>

00000224 <_exit>:
 224:	f8 94       	cli

00000226 <__stop_program>:
 226:	ff cf       	rjmp	.-2      	; 0x226 <__stop_program>
